// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Based on work by Ehlers, DasanC, and veryfid 
// @version=5

// Settings
indicator(title='Tesla Coil', overlay=false, timeframe='')
series = input(title='Series', defval=close)
mirror = true
cycle_offset = input(40)


// The Cosine IFM (Instantaneous Frequency Measurement) - Method #1
// Reference: "MEASURING CYCLES" paper by John Ehlers
getCosIFM(series) => 
    scanning_range = input(title='Scanning Range', defval=100)
    pi = 3.141592653589793238462643383279502884197
    s2 = 0.0
    s3 = 0.0
    delta1 = 0.0
    instant = 0.0
    ifm = 0.0
    value1 = 0.0
    value2 = 0.0
    value4 = 0.0
    value1 := series - series[7]
    s2 := 0.2 * (value1[1] + value1) * (value1[1] + value1) + 0.8 * nz(s2[1])
    s3 := 0.2 * (value1[1] - value1) * (value1[1] - value1) + 0.8 * nz(s3[1])
    if s2 != 0
        value2 := math.sqrt(s3 / s2)
        value2
    if s3 != 0
        delta1 := 2 * math.atan(value2)
        delta1
    for i = 0 to scanning_range by 1
        value4 += delta1[i]
        if value4 > 2 * pi and instant == 0.0
            instant := i - 1
            instant
    if instant == 0.0
        instant := instant[1]
        instant
    ifm := 0.25 * instant + 0.75 * nz(ifm[1])
    ifm

// Robust Cycle Measurement Function (I-Q Principles) - Method #2
// Reference: unknown
getRCM(series) =>
    price = series
    alpha = 0.1
    pi = 3.141592653589793238462643383279502884197
    cycle = 0.0
    q1 = 0.0
    i1 = 0.0
    i2 = 0.0
    q2 = 0.0
    delta1 = 0.0
    delta1Phase = 0.0
    medianDelta = 0.0
    dc = 0.0
    instPeriod = 0.0
    period = 0.0
    smooth = (price + 2 * price[1] + 2 * price[2] + price[3]) / 6
    cycle := (1 - 0.5 * alpha) * (1 - 0.5 * alpha) * (smooth - 2 * smooth[1] + smooth[2]) + 2 * (1 - alpha) * nz(cycle[1]) - (1 - alpha) * (1 - alpha) * nz(cycle[2])
    if bar_index < 7
        cycle := (price - 2 * price[1] + price[2]) / 4
        cycle
    q1 := (0.0962 * cycle + 0.5769 * cycle[2] - 0.5769 * cycle[4] - 0.0962 * cycle[6]) * (0.5 + 0.08 * instPeriod[1])
    i1 := cycle[3]
    if q1 != 0 and q1[1] != 0
        delta1Phase := (i1 / q1 - i1[1] / q1[1]) / (1 + i1 * i1[1] / (q1 * q1[1]))
        delta1Phase
    if delta1Phase < 0.1
        delta1Phase := 0.1
        delta1Phase
    if delta1Phase > 1.1
        delta1Phase := 1.1
        delta1Phase
    medianDelta := ta.percentile_nearest_rank(delta1Phase, 5, 50)
    if medianDelta == 0
        dc := 15
        dc
    else
        dc := 6.28318 / medianDelta + 0.5
        dc
    instPeriod := 0.33 * dc + 0.67 * nz(instPeriod[1])
    period := 0.15 * instPeriod + 0.85 * nz(period[1])
    period := math.round(period)
    period

// In-Phase & Quadrature Instantaneous Frequency Measurements (IFM) - Method #2 in the Paper
// Reference: "MEASURING CYCLES" paper by John Ehlers
getIPQ(series) =>
    pi = 3.141592653589793238462643383279502884197
    imult = 0.635
    qmult = 0.338
    inphase = 0.0
    quadrature = 0.0
    re = 0.0
    im = 0.0
    inst = 0.0
    delta1 = 0.0
    dominant_cycle = 0.0
    V = 0.0
    P = series - series[7]
    
    inphase := 1.25 * (P[4] - imult * P[2]) + imult * nz(inphase[3])
    quadrature := P[2] - qmult * P + qmult * nz(quadrature[2])
    re := 0.2 * (inphase * inphase[1] + quadrature * quadrature[1]) + 0.8 * nz(re[1])
    im := 0.2 * (inphase * quadrature[1] - inphase[1] * quadrature) + 0.8 * nz(im[1])
    if re != 0.0
        delta1 := math.atan(im / re)
        delta1
    for i = 0 to 100 by 1
        V += delta1[i]
        if V > 2 * pi and inst == 0.0
            inst := i
            inst
    if inst == 0.0
        inst := nz(inst[1])
        inst
    dominant_cycle := 0.25 * inst + 0.75 * nz(dominant_cycle[1])

// Periods
cifm_period = getCosIFM(series) // first measurement of period
rcm_period = getRCM(series) // second measurement of period
ipq_period = getIPQ(series) // third measurement of period

scaled_cifm = cifm_period * 3
average_period = math.avg(cifm_period, rcm_period, ipq_period)

cifm_mirror = cifm_period * -1 + cycle_offset
scaled_ifm_mirror = scaled_cifm * -1 + cycle_offset
average_mirror = average_period * -1  + cycle_offset

transparency = input(70)
transparency_cifm = ipq_period <= cifm_mirror + cycle_offset ? 90 : 70
transparency_cifm_mirror = scaled_cifm > scaled_ifm_mirror + cycle_offset ? 70 : 0
transparency_avg = (average_period) > average_mirror + cycle_offset ? 70 : 0

blue = input.color(#2196F3)
grey = input.color(#bbd9fb)
purple = input.color(#9575cd)
green = input.color(#4CAF50)
red = input.color(#F44336)

plot(cifm_period, 'cifm_period', color=color.new(blue, transparency_cifm))
plot(scaled_cifm, 'scaled', color=color.new(grey, transparency_cifm_mirror))

// extra periods (experimental)
plot(rcm_period, 'rcm_period', color = color.new(green, transparency_avg))
plot(ipq_period, 'ipq_period', color = color.new(red, transparency_avg))

// extra - mirrors (experimental)
plot(rcm_period*-1+cycle_offset, 'rcm_period', color = color.new(green, transparency_avg))
plot(ipq_period*-1+cycle_offset, 'ipq_period', color = color.new(red, transparency_avg))

// mirror cycles
plot(mirror ? cifm_mirror : na, 'dominant_cycle mirror', color=color.new(blue, transparency_cifm))
plot(mirror ? scaled_ifm_mirror : na, 'ifm mirror', color=color.new(grey, transparency_cifm_mirror))
plot(mirror ? average_mirror : na, 'average_period mirror', color=color.new(purple, transparency_avg))

// average cycle
plot(average_period, 'average_period', color=color.new(purple, transparency_avg))

alertcond = ta.cross(scaled_cifm, 20) or ta.cross(average_period, average_mirror + cycle_offset) or ta.cross(cifm_period, cifm_mirror + cycle_offset )
alertcondition(alertcond, title='Tesla Coil', message='Tesla Coil Crossover')


// Crosses
blue_crosses = ta.cross(cifm_period, cifm_mirror+cycle_offset)

// Section to make the intersections of lines more obvious by placing emphasis with a circle (experimental)
// Plot a circle if lines cross 
// plot(blue_crosses ? cifm_period : na, title="Cross", style=plot.style_circles, linewidth=2, color=blue)