// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© veryfid
// contribution by @KryptoBeau 

//@version=5

indicator(title='Tesla Coil', overlay=false, timeframe='')
src = input(title='Source', defval=close)
lbl = input(title='Lookback Length', defval=40)

mirror = true

//##############################################################################
// The Cosine IFM
// Copyright DasanC 2019
// https://www.tradingview.com/script/5WqrAJgu-Cosine-IFM-Ehlers/
// Calculates the real-time (low lag) plot of the cycle period in bars.
// Real-time "Period" or "Length"
getCosIFM() =>
    sRange = input(title='Scanning Range', defval=100)
    PI = 3.14159265359
    s2 = 0.0
    s3 = 0.0
    delta = 0.0
    inst = 0.0
    len = 0.0
    v1 = 0.0
    v2 = 0.0
    v4 = 0.0

    v1 := src - src[7]
    s2 := 0.2*(v1[1] + v1)*(v1[1] + v1) + 0.8*nz(s2[1])
    s3 := 0.2*(v1[1] - v1)*(v1[1] - v1) + 0.8*nz(s3[1])
    if (s2 != 0)
        v2 := math.sqrt(s3/s2)
    if (s3 != 0)
        delta := 2*math.atan(v2)
    for i = 0 to sRange
        v4 := v4 + delta[i]
        if (v4 > 2*PI and inst == 0.0)
            inst := i - 1
    if (inst == 0.0)
        inst := inst[1]
    len := 0.25*inst + 0.75*nz(len[1])
//##############################################################################




//##############################################################################
// Robust Cycle Measurement Function (I-Q Principles)
// Copyright DasanC 2019
// https://www.tradingview.com/script/KdLyZFCW-Robust-Cycle-Measurement-Ehlers/
// Sum cycle phases until it reaches 360 degrees
getRCM()=>
    // alpha = input(title="Alpha", defval=0.1)
    alpha = 0.1
    Cycle = 0.0
    Q1 = 0.0
    I1 = 0.0
    I2 = 0.0
    Q2 = 0.0
    DeltaPhase = 0.0
    MedianDelta = 0.0
    DC = 0.0
    InstPeriod = 0.0
    Period = 0.0
    
    Smooth = (src + 2*src[1] + 2*src[2] + src[3])/6
    Cycle := (1 - 0.5*alpha)*(1 - 0.5*alpha)*(Smooth - 2*Smooth[1] + Smooth[2]) + 2*(1-alpha)*nz(Cycle[1]) - (1 - alpha)*(1-alpha)*nz(Cycle[2])
    if(bar_index < 7)
        Cycle := (src - 2*src[1] + src[2])/4
    Q1 := (0.0962*Cycle + 0.5769*Cycle[2] - 0.5769*Cycle[4] - 0.0962*Cycle[6])*(0.5 + 0.08*InstPeriod[1])
    I1 := Cycle[3]
    if(Q1 != 0 and Q1[1] != 0)
        DeltaPhase := (I1/Q1 - I1[1]/Q1[1]) / (1 + I1*I1[1]/(Q1*Q1[1]))
    if(DeltaPhase < 0.1)
        DeltaPhase := 0.1
    if(DeltaPhase > 1.1)
        DeltaPhase := 1.1
    MedianDelta := ta.percentile_nearest_rank(DeltaPhase,5,50)
    if(MedianDelta==0)
        DC := 15
    else
        DC := 6.28318/MedianDelta + 0.5
    InstPeriod := 0.33*DC + 0.67*nz(InstPeriod[1])
    Period := 0.15*InstPeriod + 0.85*nz(Period[1])
    Period := math.round(Period)
//##############################################################################




//#############################################################################
//The In-phase & quadrature IFM
// Copyright DasanC 2019
// https://www.tradingview.com/script/QMfdTR0w-In-Phase-Quadrature-IFM/
// Determine the dominant cycle period of a security
getIFM()=>
    PI = 3.14159265359
    imult = 0.635
    qmult = 0.338
    inphase = 0.0
    quadrature = 0.0
    re = 0.0
    im = 0.0
    delta = 0.0
    inst = 0.0
    len = 0.0
    V = 0.0

    P = src - src[7]
    inphase := 1.25*(P[4] - imult*P[2]) + imult*nz(inphase[3])
    quadrature := P[2] - qmult*P + qmult*nz(quadrature[2])
    re := 0.2*(inphase*inphase[1] + quadrature*quadrature[1]) + 0.8*nz(re[1])
    im := 0.2*(inphase*quadrature[1] - inphase[1]*quadrature) + 0.8*nz(im[1])
    if (re!= 0.0)
        delta := math.atan(im/re)

    for i=0 to 100
        V := V + delta[i]
        if (V > 2*PI and inst == 0.0)
            inst := i

    if (inst == 0.0)
        inst := nz(inst[1])

    len := 0.25*inst + 0.75*nz(len[1])
//#############################################################################


ifm = getIFM()
cosIFM = getCosIFM() * 3
rcm = getRCM()
average = math.avg(cosIFM, rcm, ifm)

IFMColor = input(title='IFM Color', defval = #2196F3)
IFMTransp = ifm <= ifm * -1 + lbl ? 90 : 50
plot(ifm, 'IFM', color=color.new(IFMColor, IFMTransp))
plot(mirror ? ifm * -1 + lbl : na, 'IFM mirror', color = color.new(IFMColor, IFMTransp))

IFMCosColor = input(title='IFM Cos Color', defval = #bbd9fb)
IFMCosTransp = cosIFM > cosIFM * -1 + lbl ? 50 : 0
plot(cosIFM, 'Cos IFM', color=color.new(IFMCosColor, IFMCosTransp))
plot(mirror ? cosIFM * -1 + lbl : na, 'Cos IFM mirror', color = color.new(IFMCosColor, IFMCosTransp))

AverageColor = input(title='Average Color', defval = #9575cd)
AverageTransp = average > average * -1 + lbl ? 50 : 0
plot(average, 'Average', color=color.new(AverageColor, AverageTransp))
plot(mirror ? average * -1 + lbl : na, 'Average mirror', color = color.new(AverageColor, AverageTransp))

alertcond = ta.cross(cosIFM, 20) or ta.cross(average, average * -1 + lbl) or ta.cross(ifm, ifm * -1 + lbl )
alertcondition(alertcond, title='Tesla Coil', message='Tesla Coil Crossover')